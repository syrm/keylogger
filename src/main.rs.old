use std::collections::HashMap;
use std::fs;
use std::io::Read;
use std::os::fd::{AsRawFd, RawFd};
use std::ptr::null;
use mio::Token;
use mio::unix::SourceFd;

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable, Debug)]
struct InputEvent {
    tv_sec: u64,
    tv_usec: u64,
    event_type: u16,
    code: u16,
    value: i32,
}

const EV_KEY: u16 = 0x01;
const EV_MSC_SCAN: u16 = 0x04;

// org.freedesktop.portal.RemoteDesktop
fn main() {
    assert_eq!(std::mem::size_of::<InputEvent>(), 24);

    let dir_entry = fs::read_dir("/dev/input");

    let dir = match dir_entry {
        Ok(dir) => dir,
        Err(_) => panic!("Error reading /dev/input"),
    };

    let Ok(mut poll) = mio::Poll::new() else {
        panic!("Error creating mio::Poll");
    };

    let mut hashmap_file: HashMap<Token, fs::File> = HashMap::new();

    for (index, entry) in dir.into_iter().enumerate() {
        let Ok(entry) = entry else { continue };

        if entry.path().is_dir() { continue };

        let Ok(mut file) = fs::File::open(entry.path()) else {
            println!("Warn, can't open {:?}", entry.path());
            continue
        };

        let token = Token(index);

        let Ok(file_for_map) = file.try_clone() else {
            eprintln!("Error cloning {:?}", entry.path());
            continue
        };

        let mut raw_fd = file.as_raw_fd();

        let Ok(_) = poll.registry().register(
            &mut SourceFd(&mut raw_fd),
            token,
            mio::Interest::READABLE,
        ) else {
            eprintln!("Error registering {:?}", entry.path());
            continue
        };

        hashmap_file.insert(token, file);
    }

    println!("Start Poll");
    let mut events = mio::Events::with_capacity(1024);

    loop {
        if poll.poll(&mut events, None).is_err() {
            eprintln!("Error polling");
        }

        // println!("loop on event size: {}", events.into_iter().count());

        for event in events.iter() {
            let Some(mut fd) = hashmap_file.get(&event.token()) else {
                eprintln!("Error getting file");
                continue
            };

            let buf = &mut [0; std::mem::size_of::<InputEvent>()];
            let mut input_event: Option<InputEvent> = None;

            loop {
                let Ok(n) = fd.read(buf) else {
                    eprintln!("Error reading file");
                    break;
                };

                input_event = Some(*bytemuck::from_bytes(buf));

                if let Some(ie) = input_event && ie.event_type != EV_MSC_SCAN { break };
            }

            let Some(input_event) = input_event else { continue };

                if input_event.event_type != EV_KEY { continue };
                // if input_event.value != 1 { continue };

                println!("Event {:?}", input_event);
                println!("{:?}", input_event.code as u8 as char);
                // if n < buf.len() { break; }
            // }
        }
    }
}
